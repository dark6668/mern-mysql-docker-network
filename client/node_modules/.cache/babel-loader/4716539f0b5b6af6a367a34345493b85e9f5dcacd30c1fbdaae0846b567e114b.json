{"ast":null,"code":"import { jwtDecode } from \"jwt-decode\";\nexport default function FetchRequest(request) {\n  try {\n    return new Promise((resolve, reject) => {\n      fetch(`${process.env.REACT_APP_API_URL}/${request.url}`, {\n        method: request.method,\n        body: request.method === \"GET\" ? null : request.body,\n        headers: {\n          \"Content-Type\": request.ContentType,\n          ...(someCondition && {\n            \"Authorization\": `Bearer ${accessToken}`\n          })\n        }\n      }).then(response => {\n        if (response.status !== 200) {\n          response.json().then(errorData => {\n            reject(errorData);\n          });\n        } else {\n          response.json().then(responseData => {\n            resolve(responseData);\n          }).catch(err => {\n            console.log(err);\n          });\n        }\n      });\n    });\n  } catch (err) {\n    console.log(err);\n  }\n}\n_c = FetchRequest;\nexport function checkAccessTokenExpiresIn() {\n  return new Promise((resolve, reject) => {\n    try {\n      const decodedToken = jwtDecode(sessionStorage.getItem(\"accessToken\"));\n      const expirationTime = decodedToken.exp * 1000;\n      if (expirationTime < Date.now()) return reject(\"Access token has expired\");\n      resolve(decodedToken);\n    } catch (error) {\n      reject(new Error(\"Failed to decode access token\"));\n    }\n  });\n}\nexport function makeNewAccessToken(newAccessToken) {\n  return new Promise((resolve, reject) => {\n    try {\n      sessionStorage.removeItem(\"accessToken\");\n      sessionStorage.setItem(\"accessToken\", newAccessToken);\n      resolve(true);\n    } catch (error) {\n      console.error(error);\n      reject(false);\n    }\n  });\n}\nvar _c;\n$RefreshReg$(_c, \"FetchRequest\");","map":{"version":3,"names":["jwtDecode","FetchRequest","request","Promise","resolve","reject","fetch","process","env","REACT_APP_API_URL","url","method","body","headers","ContentType","someCondition","accessToken","then","response","status","json","errorData","responseData","catch","err","console","log","_c","checkAccessTokenExpiresIn","decodedToken","sessionStorage","getItem","expirationTime","exp","Date","now","error","Error","makeNewAccessToken","newAccessToken","removeItem","setItem","$RefreshReg$"],"sources":["/react/src/function/utility.js"],"sourcesContent":["import { jwtDecode } from \"jwt-decode\";\nexport default function FetchRequest(request) {\n  try {\n    return new Promise((resolve, reject) => {\n      fetch(`${process.env.REACT_APP_API_URL}/${request.url}`, {\n        method: request.method,\n        body: request.method === \"GET\" ? null : request.body,\n        headers: {\n          \"Content-Type\": request.ContentType,\n          ...(someCondition && { \"Authorization\": `Bearer ${accessToken}` }),\n        },\n      }).then((response) => {\n        if (response.status !== 200) {\n          response.json().then((errorData) => {\n            reject(errorData);\n          });\n        } else {\n          response\n            .json()\n            .then((responseData) => {\n              resolve(responseData);\n            })\n            .catch((err) => {\n              console.log(err);\n            });\n        }\n      });\n    });\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n\nexport function checkAccessTokenExpiresIn() {\n  return new Promise((resolve, reject) => {\n    try {\n      const decodedToken = jwtDecode(sessionStorage.getItem(\"accessToken\"));\n\n      const expirationTime = decodedToken.exp * 1000;\n\n      if (expirationTime < Date.now())\n        return reject(\"Access token has expired\");\n      resolve(decodedToken);\n    } catch (error) {\n      reject(new Error(\"Failed to decode access token\"));\n    }\n  });\n}\nexport function makeNewAccessToken(newAccessToken) {\n  return new Promise((resolve, reject) => {\n    try {\n      sessionStorage.removeItem(\"accessToken\");\n      sessionStorage.setItem(\"accessToken\", newAccessToken);\n      resolve(true);\n    } catch (error) {\n      console.error(error);\n      reject(false);\n    }\n  });\n}"],"mappings":"AAAA,SAASA,SAAS,QAAQ,YAAY;AACtC,eAAe,SAASC,YAAYA,CAACC,OAAO,EAAE;EAC5C,IAAI;IACF,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtCC,KAAK,CAAE,GAAEC,OAAO,CAACC,GAAG,CAACC,iBAAkB,IAAGP,OAAO,CAACQ,GAAI,EAAC,EAAE;QACvDC,MAAM,EAAET,OAAO,CAACS,MAAM;QACtBC,IAAI,EAAEV,OAAO,CAACS,MAAM,KAAK,KAAK,GAAG,IAAI,GAAGT,OAAO,CAACU,IAAI;QACpDC,OAAO,EAAE;UACP,cAAc,EAAEX,OAAO,CAACY,WAAW;UACnC,IAAIC,aAAa,IAAI;YAAE,eAAe,EAAG,UAASC,WAAY;UAAE,CAAC;QACnE;MACF,CAAC,CAAC,CAACC,IAAI,CAAEC,QAAQ,IAAK;QACpB,IAAIA,QAAQ,CAACC,MAAM,KAAK,GAAG,EAAE;UAC3BD,QAAQ,CAACE,IAAI,CAAC,CAAC,CAACH,IAAI,CAAEI,SAAS,IAAK;YAClChB,MAAM,CAACgB,SAAS,CAAC;UACnB,CAAC,CAAC;QACJ,CAAC,MAAM;UACLH,QAAQ,CACLE,IAAI,CAAC,CAAC,CACNH,IAAI,CAAEK,YAAY,IAAK;YACtBlB,OAAO,CAACkB,YAAY,CAAC;UACvB,CAAC,CAAC,CACDC,KAAK,CAAEC,GAAG,IAAK;YACdC,OAAO,CAACC,GAAG,CAACF,GAAG,CAAC;UAClB,CAAC,CAAC;QACN;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,CAAC,OAAOA,GAAG,EAAE;IACZC,OAAO,CAACC,GAAG,CAACF,GAAG,CAAC;EAClB;AACF;AAACG,EAAA,GA9BuB1B,YAAY;AAiCpC,OAAO,SAAS2B,yBAAyBA,CAAA,EAAG;EAC1C,OAAO,IAAIzB,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,IAAI;MACF,MAAMwB,YAAY,GAAG7B,SAAS,CAAC8B,cAAc,CAACC,OAAO,CAAC,aAAa,CAAC,CAAC;MAErE,MAAMC,cAAc,GAAGH,YAAY,CAACI,GAAG,GAAG,IAAI;MAE9C,IAAID,cAAc,GAAGE,IAAI,CAACC,GAAG,CAAC,CAAC,EAC7B,OAAO9B,MAAM,CAAC,0BAA0B,CAAC;MAC3CD,OAAO,CAACyB,YAAY,CAAC;IACvB,CAAC,CAAC,OAAOO,KAAK,EAAE;MACd/B,MAAM,CAAC,IAAIgC,KAAK,CAAC,+BAA+B,CAAC,CAAC;IACpD;EACF,CAAC,CAAC;AACJ;AACA,OAAO,SAASC,kBAAkBA,CAACC,cAAc,EAAE;EACjD,OAAO,IAAIpC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,IAAI;MACFyB,cAAc,CAACU,UAAU,CAAC,aAAa,CAAC;MACxCV,cAAc,CAACW,OAAO,CAAC,aAAa,EAAEF,cAAc,CAAC;MACrDnC,OAAO,CAAC,IAAI,CAAC;IACf,CAAC,CAAC,OAAOgC,KAAK,EAAE;MACdX,OAAO,CAACW,KAAK,CAACA,KAAK,CAAC;MACpB/B,MAAM,CAAC,KAAK,CAAC;IACf;EACF,CAAC,CAAC;AACJ;AAAC,IAAAsB,EAAA;AAAAe,YAAA,CAAAf,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}