{"ast":null,"code":"import { jwtDecode } from \"jwt-decode\";\nexport default class Utility {\n  async FetchRequest(request) {\n    try {\n      return new Promise((resolve, reject) => {\n        console.log(1);\n        fetch(`${process.env.REACT_APP_API_URL}/${request.url}`, {\n          method: request.method,\n          body: request.method === \"GET\" ? null : request.body,\n          headers: {\n            \"Content-Type\": request.ContentType\n            // ...(someCondition && { \"Authorization\": `Bearer ${accessToken}` }),\n          }\n        }).then(response => {\n          if (response.status !== 200) {\n            response.json().then(errorData => {\n              reject(errorData);\n            });\n          } else {\n            response.json().then(responseData => {\n              resolve(responseData);\n            }).catch(err => {\n              console.log(err);\n            });\n          }\n        });\n      });\n    } catch (err) {\n      console.log(err);\n    }\n  }\n  checkAccessTokenExpiresIn() {\n    return new Promise((resolve, reject) => {\n      try {\n        const decodedToken = jwtDecode(sessionStorage.getItem(\"accessToken\"));\n        const expirationTime = decodedToken.exp * 1000;\n        if (expirationTime < Date.now()) return reject(\"Access token has expired\");\n        resolve(decodedToken);\n      } catch (error) {\n        reject(new Error(\"Failed to decode access token\"));\n      }\n    });\n  }\n  makeNewAccessToken(newAccessToken) {\n    return new Promise((resolve, reject) => {\n      try {\n        sessionStorage.removeItem(\"accessToken\");\n        sessionStorage.setItem(\"accessToken\", newAccessToken);\n        resolve(true);\n      } catch (error) {\n        console.error(error);\n        reject(false);\n      }\n    });\n  }\n}\n// export  default function FetchRequest(request) {\n//   try {\n//     return new Promise((resolve, reject) => {\n//       fetch(`${process.env.REACT_APP_API_URL}/${request.url}`, {\n//         method: request.method,\n//         body: request.method === \"GET\" ? null : request.body,\n//         headers: {\n//           \"Content-Type\": request.ContentType,\n//           // ...(someCondition && { \"Authorization\": `Bearer ${accessToken}` }),\n//         },\n//       }).then((response) => {\n//         if (response.status !== 200) {\n//           response.json().then((errorData) => {\n//             reject(errorData);\n//           });\n//         } else {\n//           response\n//             .json()\n//             .then((responseData) => {\n//               resolve(responseData);\n//             })\n//             .catch((err) => {\n//               console.log(err);\n//             });\n//         }\n//       });\n//     });\n//   } catch (err) {\n//     console.log(err);\n//   }\n// }\n\n// export  default function checkAccessTokenExpiresIn() {\n//   return new Promise((resolve, reject) => {\n//     try {\n//       const decodedToken = jwtDecode(sessionStorage.getItem(\"accessToken\"));\n\n//       const expirationTime = decodedToken.exp * 1000;\n\n//       if (expirationTime < Date.now())\n//         return reject(\"Access token has expired\");\n//       resolve(decodedToken);\n//     } catch (error) {\n//       reject(new Error(\"Failed to decode access token\"));\n//     }\n//   });\n// }\n// export  default function makeNewAccessToken(newAccessToken) {\n//   return new Promise((resolve, reject) => {\n//     try {\n//       sessionStorage.removeItem(\"accessToken\");\n//       sessionStorage.setItem(\"accessToken\", newAccessToken);\n//       resolve(true);\n//     } catch (error) {\n//       console.error(error);\n//       reject(false);\n//     }\n//   });\n// }","map":{"version":3,"names":["jwtDecode","Utility","FetchRequest","request","Promise","resolve","reject","console","log","fetch","process","env","REACT_APP_API_URL","url","method","body","headers","ContentType","then","response","status","json","errorData","responseData","catch","err","checkAccessTokenExpiresIn","decodedToken","sessionStorage","getItem","expirationTime","exp","Date","now","error","Error","makeNewAccessToken","newAccessToken","removeItem","setItem"],"sources":["/react/src/function/utility.js"],"sourcesContent":["import { jwtDecode } from \"jwt-decode\";\n\nexport  default class Utility{\n\n\n  async FetchRequest(request){\n    try {\n\n      return new Promise((resolve, reject) => {\n        console.log(1);\n        fetch(`${process.env.REACT_APP_API_URL}/${request.url}`, {\n          method: request.method,\n          body: request.method === \"GET\" ? null : request.body,\n          headers: {\n            \"Content-Type\": request.ContentType,\n            // ...(someCondition && { \"Authorization\": `Bearer ${accessToken}` }),\n          },\n        }).then((response) => {\n          if (response.status !== 200) {\n            response.json().then((errorData) => {\n              reject(errorData);\n            });\n          } else {\n            response\n              .json()\n              .then((responseData) => {\n                resolve(responseData);\n              })\n              .catch((err) => {\n                console.log(err);\n              });\n          }\n        });\n      });\n    } catch (err) {\n      console.log(err);\n    }\n  }\n  checkAccessTokenExpiresIn(){\n    return new Promise((resolve, reject) => {\n      try {\n        const decodedToken = jwtDecode(sessionStorage.getItem(\"accessToken\"));\n  \n        const expirationTime = decodedToken.exp * 1000;\n  \n        if (expirationTime < Date.now())\n          return reject(\"Access token has expired\");\n        resolve(decodedToken);\n      } catch (error) {\n        reject(new Error(\"Failed to decode access token\"));\n      }\n    });\n  }\n  makeNewAccessToken(newAccessToken){\n    return new Promise((resolve, reject) => {\n      try {\n        sessionStorage.removeItem(\"accessToken\");\n        sessionStorage.setItem(\"accessToken\", newAccessToken);\n        resolve(true);\n      } catch (error) {\n        console.error(error);\n        reject(false);\n      }\n    });\n  }\n}\n// export  default function FetchRequest(request) {\n//   try {\n//     return new Promise((resolve, reject) => {\n//       fetch(`${process.env.REACT_APP_API_URL}/${request.url}`, {\n//         method: request.method,\n//         body: request.method === \"GET\" ? null : request.body,\n//         headers: {\n//           \"Content-Type\": request.ContentType,\n//           // ...(someCondition && { \"Authorization\": `Bearer ${accessToken}` }),\n//         },\n//       }).then((response) => {\n//         if (response.status !== 200) {\n//           response.json().then((errorData) => {\n//             reject(errorData);\n//           });\n//         } else {\n//           response\n//             .json()\n//             .then((responseData) => {\n//               resolve(responseData);\n//             })\n//             .catch((err) => {\n//               console.log(err);\n//             });\n//         }\n//       });\n//     });\n//   } catch (err) {\n//     console.log(err);\n//   }\n// }\n\n\n// export  default function checkAccessTokenExpiresIn() {\n//   return new Promise((resolve, reject) => {\n//     try {\n//       const decodedToken = jwtDecode(sessionStorage.getItem(\"accessToken\"));\n\n//       const expirationTime = decodedToken.exp * 1000;\n\n//       if (expirationTime < Date.now())\n//         return reject(\"Access token has expired\");\n//       resolve(decodedToken);\n//     } catch (error) {\n//       reject(new Error(\"Failed to decode access token\"));\n//     }\n//   });\n// }\n// export  default function makeNewAccessToken(newAccessToken) {\n//   return new Promise((resolve, reject) => {\n//     try {\n//       sessionStorage.removeItem(\"accessToken\");\n//       sessionStorage.setItem(\"accessToken\", newAccessToken);\n//       resolve(true);\n//     } catch (error) {\n//       console.error(error);\n//       reject(false);\n//     }\n//   });\n// }"],"mappings":"AAAA,SAASA,SAAS,QAAQ,YAAY;AAEtC,eAAgB,MAAMC,OAAO;EAG3B,MAAMC,YAAYA,CAACC,OAAO,EAAC;IACzB,IAAI;MAEF,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;QACtCC,OAAO,CAACC,GAAG,CAAC,CAAC,CAAC;QACdC,KAAK,CAAE,GAAEC,OAAO,CAACC,GAAG,CAACC,iBAAkB,IAAGT,OAAO,CAACU,GAAI,EAAC,EAAE;UACvDC,MAAM,EAAEX,OAAO,CAACW,MAAM;UACtBC,IAAI,EAAEZ,OAAO,CAACW,MAAM,KAAK,KAAK,GAAG,IAAI,GAAGX,OAAO,CAACY,IAAI;UACpDC,OAAO,EAAE;YACP,cAAc,EAAEb,OAAO,CAACc;YACxB;UACF;QACF,CAAC,CAAC,CAACC,IAAI,CAAEC,QAAQ,IAAK;UACpB,IAAIA,QAAQ,CAACC,MAAM,KAAK,GAAG,EAAE;YAC3BD,QAAQ,CAACE,IAAI,CAAC,CAAC,CAACH,IAAI,CAAEI,SAAS,IAAK;cAClChB,MAAM,CAACgB,SAAS,CAAC;YACnB,CAAC,CAAC;UACJ,CAAC,MAAM;YACLH,QAAQ,CACLE,IAAI,CAAC,CAAC,CACNH,IAAI,CAAEK,YAAY,IAAK;cACtBlB,OAAO,CAACkB,YAAY,CAAC;YACvB,CAAC,CAAC,CACDC,KAAK,CAAEC,GAAG,IAAK;cACdlB,OAAO,CAACC,GAAG,CAACiB,GAAG,CAAC;YAClB,CAAC,CAAC;UACN;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOA,GAAG,EAAE;MACZlB,OAAO,CAACC,GAAG,CAACiB,GAAG,CAAC;IAClB;EACF;EACAC,yBAAyBA,CAAA,EAAE;IACzB,OAAO,IAAItB,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI;QACF,MAAMqB,YAAY,GAAG3B,SAAS,CAAC4B,cAAc,CAACC,OAAO,CAAC,aAAa,CAAC,CAAC;QAErE,MAAMC,cAAc,GAAGH,YAAY,CAACI,GAAG,GAAG,IAAI;QAE9C,IAAID,cAAc,GAAGE,IAAI,CAACC,GAAG,CAAC,CAAC,EAC7B,OAAO3B,MAAM,CAAC,0BAA0B,CAAC;QAC3CD,OAAO,CAACsB,YAAY,CAAC;MACvB,CAAC,CAAC,OAAOO,KAAK,EAAE;QACd5B,MAAM,CAAC,IAAI6B,KAAK,CAAC,+BAA+B,CAAC,CAAC;MACpD;IACF,CAAC,CAAC;EACJ;EACAC,kBAAkBA,CAACC,cAAc,EAAC;IAChC,OAAO,IAAIjC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI;QACFsB,cAAc,CAACU,UAAU,CAAC,aAAa,CAAC;QACxCV,cAAc,CAACW,OAAO,CAAC,aAAa,EAAEF,cAAc,CAAC;QACrDhC,OAAO,CAAC,IAAI,CAAC;MACf,CAAC,CAAC,OAAO6B,KAAK,EAAE;QACd3B,OAAO,CAAC2B,KAAK,CAACA,KAAK,CAAC;QACpB5B,MAAM,CAAC,KAAK,CAAC;MACf;IACF,CAAC,CAAC;EACJ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}