{"ast":null,"code":"import { jwtDecode } from \"jwt-decode\";\nexport default class Utility {\n  static async FetchRequest(request) {\n    try {\n      return new Promise((resolve, reject) => {\n        fetch(`${process.env.REACT_APP_API_URL}/${request.url}`, {\n          method: request.method,\n          body: request.method === \"GET\" ? null : request.body,\n          headers: {\n            \"Content-Type\": request.ContentType,\n            ...(request.Authorization != undefined && {\n              \"Authorization\": `Bearer ${sessionStorage.getItem(\"accessToken\")}`\n            })\n          }\n        }).then(response => {\n          if (response.ok) {\n            response.json().then(responseData => {\n              resolve({\n                success: true,\n                data: responseData\n              });\n            });\n          } else {\n            response.json().then(errorData => {\n              // Resolve the promise with an object containing error information\n              resolve({\n                success: false,\n                error: errorData\n              });\n            });\n          }\n        }).catch(err => {\n          console.error(\"Fetch error:\", err);\n          reject({\n            error: err\n          });\n        });\n      });\n    } catch (err) {\n      console.log(err);\n    }\n  }\n  static checkAccessTokenExpiresIn() {\n    return new Promise((resolve, reject) => {\n      try {\n        const decodedToken = jwtDecode(sessionStorage.getItem(\"accessToken\"));\n        const expirationTime = decodedToken.exp * 1000;\n        if (expirationTime < Date.now()) return reject(\"Access token has expired\");\n        resolve(decodedToken);\n      } catch (error) {\n        reject(new Error(\"Failed to decode access token\"));\n      }\n    });\n  }\n  static makeNewAccessToken(newAccessToken) {\n    return new Promise((resolve, reject) => {\n      try {\n        sessionStorage.removeItem(\"accessToken\");\n        sessionStorage.setItem(\"accessToken\", newAccessToken);\n        resolve(true);\n      } catch (error) {\n        console.error(error);\n        reject(false);\n      }\n    });\n  }\n}","map":{"version":3,"names":["jwtDecode","Utility","FetchRequest","request","Promise","resolve","reject","fetch","process","env","REACT_APP_API_URL","url","method","body","headers","ContentType","Authorization","undefined","sessionStorage","getItem","then","response","ok","json","responseData","success","data","errorData","error","catch","err","console","log","checkAccessTokenExpiresIn","decodedToken","expirationTime","exp","Date","now","Error","makeNewAccessToken","newAccessToken","removeItem","setItem"],"sources":["/react/src/function/utility.js"],"sourcesContent":["import { jwtDecode } from \"jwt-decode\";\n\nexport default class Utility {\n  static async FetchRequest(request) {\n    try {\n      return new Promise((resolve, reject) => {\n        fetch(`${process.env.REACT_APP_API_URL}/${request.url}`, {\n          method: request.method,\n          body: request.method === \"GET\" ? null : request.body,\n          headers: {\n            \"Content-Type\": request.ContentType,\n            ...(request.Authorization != undefined && { \"Authorization\": `Bearer ${sessionStorage.getItem(\"accessToken\")}` }),\n          },\n        }).then((response) => {\n          if (response.ok) {\n            response.json().then((responseData) => {\n              resolve({ success: true, data: responseData });\n            });\n          } else {\n            response.json().then((errorData) => {\n              // Resolve the promise with an object containing error information\n              resolve({ success: false, error: errorData });\n            });\n          }\n        }).catch((err) => {\n          console.error(\"Fetch error:\", err);\n          reject({error: err });\n        });\n      });\n    } catch (err) {\n      console.log(err);\n    }\n  }\n\n  static checkAccessTokenExpiresIn(){\n    return new Promise((resolve, reject) => {\n      try {\n        const decodedToken = jwtDecode(sessionStorage.getItem(\"accessToken\"));\n  \n        const expirationTime = decodedToken.exp * 1000;\n  \n        if (expirationTime < Date.now())\n          return reject(\"Access token has expired\");\n        resolve(decodedToken);\n      } catch (error) {\n        reject(new Error(\"Failed to decode access token\"));\n      }\n    });\n  }\n  static makeNewAccessToken(newAccessToken){\n    return new Promise((resolve, reject) => {\n      try {\n        sessionStorage.removeItem(\"accessToken\");\n        sessionStorage.setItem(\"accessToken\", newAccessToken);\n        resolve(true);\n      } catch (error) {\n        console.error(error);\n        reject(false);\n      }\n    });\n  }\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,YAAY;AAEtC,eAAe,MAAMC,OAAO,CAAC;EAC3B,aAAaC,YAAYA,CAACC,OAAO,EAAE;IACjC,IAAI;MACF,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;QACtCC,KAAK,CAAE,GAAEC,OAAO,CAACC,GAAG,CAACC,iBAAkB,IAAGP,OAAO,CAACQ,GAAI,EAAC,EAAE;UACvDC,MAAM,EAAET,OAAO,CAACS,MAAM;UACtBC,IAAI,EAAEV,OAAO,CAACS,MAAM,KAAK,KAAK,GAAG,IAAI,GAAGT,OAAO,CAACU,IAAI;UACpDC,OAAO,EAAE;YACP,cAAc,EAAEX,OAAO,CAACY,WAAW;YACnC,IAAIZ,OAAO,CAACa,aAAa,IAAIC,SAAS,IAAI;cAAE,eAAe,EAAG,UAASC,cAAc,CAACC,OAAO,CAAC,aAAa,CAAE;YAAE,CAAC;UAClH;QACF,CAAC,CAAC,CAACC,IAAI,CAAEC,QAAQ,IAAK;UACpB,IAAIA,QAAQ,CAACC,EAAE,EAAE;YACfD,QAAQ,CAACE,IAAI,CAAC,CAAC,CAACH,IAAI,CAAEI,YAAY,IAAK;cACrCnB,OAAO,CAAC;gBAAEoB,OAAO,EAAE,IAAI;gBAAEC,IAAI,EAAEF;cAAa,CAAC,CAAC;YAChD,CAAC,CAAC;UACJ,CAAC,MAAM;YACLH,QAAQ,CAACE,IAAI,CAAC,CAAC,CAACH,IAAI,CAAEO,SAAS,IAAK;cAClC;cACAtB,OAAO,CAAC;gBAAEoB,OAAO,EAAE,KAAK;gBAAEG,KAAK,EAAED;cAAU,CAAC,CAAC;YAC/C,CAAC,CAAC;UACJ;QACF,CAAC,CAAC,CAACE,KAAK,CAAEC,GAAG,IAAK;UAChBC,OAAO,CAACH,KAAK,CAAC,cAAc,EAAEE,GAAG,CAAC;UAClCxB,MAAM,CAAC;YAACsB,KAAK,EAAEE;UAAI,CAAC,CAAC;QACvB,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOA,GAAG,EAAE;MACZC,OAAO,CAACC,GAAG,CAACF,GAAG,CAAC;IAClB;EACF;EAEA,OAAOG,yBAAyBA,CAAA,EAAE;IAChC,OAAO,IAAI7B,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI;QACF,MAAM4B,YAAY,GAAGlC,SAAS,CAACkB,cAAc,CAACC,OAAO,CAAC,aAAa,CAAC,CAAC;QAErE,MAAMgB,cAAc,GAAGD,YAAY,CAACE,GAAG,GAAG,IAAI;QAE9C,IAAID,cAAc,GAAGE,IAAI,CAACC,GAAG,CAAC,CAAC,EAC7B,OAAOhC,MAAM,CAAC,0BAA0B,CAAC;QAC3CD,OAAO,CAAC6B,YAAY,CAAC;MACvB,CAAC,CAAC,OAAON,KAAK,EAAE;QACdtB,MAAM,CAAC,IAAIiC,KAAK,CAAC,+BAA+B,CAAC,CAAC;MACpD;IACF,CAAC,CAAC;EACJ;EACA,OAAOC,kBAAkBA,CAACC,cAAc,EAAC;IACvC,OAAO,IAAIrC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI;QACFY,cAAc,CAACwB,UAAU,CAAC,aAAa,CAAC;QACxCxB,cAAc,CAACyB,OAAO,CAAC,aAAa,EAAEF,cAAc,CAAC;QACrDpC,OAAO,CAAC,IAAI,CAAC;MACf,CAAC,CAAC,OAAOuB,KAAK,EAAE;QACdG,OAAO,CAACH,KAAK,CAACA,KAAK,CAAC;QACpBtB,MAAM,CAAC,KAAK,CAAC;MACf;IACF,CAAC,CAAC;EACJ;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}